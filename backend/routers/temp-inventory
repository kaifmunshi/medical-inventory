# F:\medical-inventory\backend\routers\inventory.py

from fastapi import APIRouter, HTTPException, Query, Request
from sqlmodel import select
from datetime import datetime
from typing import List, Optional
from pydantic import BaseModel
import logging
from sqlalchemy import func
from sqlalchemy.sql import or_

from backend.db import get_session
from backend.models import Item, StockMovement  # ✅ NEW

logger = logging.getLogger("api.items")

router = APIRouter()

# ---------- Local Schemas (NO batch_no) ----------
class ItemIn(BaseModel):
    name: str
    brand: Optional[str] = None
    expiry_date: Optional[str] = None  # "YYYY-MM-DD"
    mrp: float
    stock: int

    # ✅ NEW
    rack_number: int = 0

    class Config:
        extra = "ignore"  # ignore legacy 'batch_no' if a stale client sends it


class ItemUpdateIn(BaseModel):
    name: Optional[str] = None
    brand: Optional[str] = None
    expiry_date: Optional[str] = None
    mrp: Optional[float] = None
    stock: Optional[int] = None

    # ✅ NEW
    rack_number: Optional[int] = None

    class Config:
        extra = "ignore"  # ignore legacy 'batch_no'


class ItemOut(BaseModel):
    id: int
    name: str
    brand: Optional[str] = None
    expiry_date: Optional[str] = None
    mrp: float
    stock: int

    # ✅ NEW
    rack_number: int

    created_at: str
    updated_at: str

    class Config:
        from_attributes = True  # pydantic v2 (orm_mode=True in v1)


# ✅ NEW: paginated response envelope for infinite scroll
class ItemPageOut(BaseModel):
    items: List[ItemOut]
    total: int
    next_offset: Optional[int] = None


# ---------------- Ledger Response Models (NEW) ----------------
class StockMovementOut(BaseModel):
    id: int
    ts: str
    delta: int
    reason: str
    ref_type: Optional[str] = None
    ref_id: Optional[int] = None
    note: Optional[str] = None
    actor: Optional[str] = None

    # ✅ helpful for UI
    balance_after: int
    balance_before: int

    class Config:
        from_attributes = True


class StockLedgerPageOut(BaseModel):
    item_id: int
    item_name: str
    current_stock: int
    items: List[StockMovementOut]
    next_offset: Optional[int] = None


# ---------- Helpers ----------
def now_ts():
    return datetime.now().isoformat(timespec="seconds")


def add_movement(
    session,
    *,
    item_id: int,
    delta: int,
    reason: str,
    ref_type: Optional[str] = None,
    ref_id: Optional[int] = None,
    note: Optional[str] = None,
    actor: Optional[str] = None,
):
    """
    Append-only ledger row. Never edits existing movements.
    """
    mv = StockMovement(
        item_id=int(item_id),
        ts=now_ts(),
        delta=int(delta),
        reason=str(reason),
        ref_type=ref_type,
        ref_id=ref_id,
        note=note,
        actor=actor,
    )
    session.add(mv)


# ---------- Endpoints ----------
@router.get("/", response_model=ItemPageOut)
def list_items(
    request: Request,
    q: Optional[str] = Query(None, description="Search in name/brand"),
    limit: Optional[int] = Query(None, ge=1, le=500),
    offset: Optional[int] = Query(None, ge=0),
):
    with get_session() as session:
        base_stmt = select(Item)

        if q:
            like = f"%{q.strip()}%"
            base_stmt = base_stmt.where(
                or_(
                    Item.name.ilike(like),
                    Item.brand.ilike(like),
                )
            )

        # ✅ If ONLY q is present (client didn't pass limit/offset), return ALL matches
        if q and limit is None and offset is None:
            stmt = base_stmt.order_by(Item.name, Item.id)
            items = session.exec(stmt).all()
            total = len(items)
            return {"items": items, "total": total, "next_offset": None}

        # ✅ Otherwise paginate (defaults if not provided)
        page_limit = limit if limit is not None else 500
        page_offset = offset if offset is not None else 0

        # total count (filtered)
        count_stmt = select(func.count()).select_from(base_stmt.subquery())
        total = session.exec(count_stmt).one()

        # paginated items (stable order)
        page_stmt = (
            base_stmt
            .order_by(Item.name, Item.id)
            .limit(page_limit)
            .offset(page_offset)
        )
        items = session.exec(page_stmt).all()

        next_offset = (
            page_offset + page_limit
            if (page_offset + page_limit) < total
            else None
        )

        return {
            "items": items,
            "total": total,
            "next_offset": next_offset,
        }


@router.get("/{item_id}", response_model=ItemOut)
def get_item(item_id: int):
    with get_session() as session:
        item = session.get(Item, item_id)
        if not item:
            raise HTTPException(status_code=404, detail="Item not found")
        return item

@router.post("/", response_model=ItemOut, status_code=201)
def create_item(payload: ItemIn):
    if payload.mrp <= 0:
        raise HTTPException(status_code=400, detail="MRP must be > 0")
    if payload.stock is not None and payload.stock < 0:
        raise HTTPException(status_code=400, detail="Stock cannot be negative")

    # ✅ NEW: rack validation
    if payload.rack_number is not None and int(payload.rack_number) < 0:
        raise HTTPException(status_code=400, detail="Rack number cannot be negative")

    with get_session() as session:
        try:
            item = Item(
                name=payload.name,
                brand=payload.brand,
                expiry_date=payload.expiry_date,
                mrp=payload.mrp,
                stock=payload.stock,

                # ✅ NEW
                rack_number=int(payload.rack_number or 0),

                created_at=now_ts(),
                updated_at=now_ts(),
            )
            session.add(item)
            session.commit()
            session.refresh(item)

            # # ✅ Ledger: opening stock entry (only if non-zero)
            # if int(item.stock or 0) != 0:
            #     add_movement(
            #         session,
            #         item_id=item.id,
            #         delta=int(item.stock),
            #         reason="OPENING",
            #         ref_type="ITEM",
            #         ref_id=item.id,
            #         note="Opening stock at item creation",
            #     )
            #     session.commit()
            # ✅ Ledger: opening stock entry (only if non-zero)
            if int(item.stock or 0) != 0:
                try:
                    add_movement(
                        session,
                        item_id=item.id,
                        delta=int(item.stock),
                        reason="OPENING",
                        ref_type="ITEM",
                        ref_id=item.id,
                        note="Opening stock at item creation",
                    )
                    session.commit()
                except Exception as e:
                    session.rollback()
                    logger.exception("Ledger insert failed (ignored to keep item creation working): %s", e)


            return item

        except Exception as e:
            session.rollback()
            raise HTTPException(status_code=500, detail=f"Failed to create item: {e}")


@router.patch("/{item_id}", response_model=ItemOut)
def update_item(item_id: int, payload: ItemUpdateIn):
    with get_session() as session:
        item = session.get(Item, item_id)
        if not item:
            raise HTTPException(status_code=404, detail="Item not found")

        data = payload.model_dump(exclude_unset=True)

        # Basic validations
        if "mrp" in data and data["mrp"] is not None and data["mrp"] <= 0:
            raise HTTPException(status_code=400, detail="MRP must be > 0")
        if "stock" in data and data["stock"] is not None and data["stock"] < 0:
            raise HTTPException(status_code=400, detail="Stock cannot be negative")

        # ✅ NEW: rack validation
        if "rack_number" in data and data["rack_number"] is not None and int(data["rack_number"]) < 0:
            raise HTTPException(status_code=400, detail="Rack number cannot be negative")

        for k, v in data.items():
            if k == "rack_number" and v is not None:
                setattr(item, k, int(v))
            else:
                setattr(item, k, v)

        item.updated_at = now_ts()

        session.add(item)
        session.commit()
        session.refresh(item)
        return item


@router.delete("/{item_id}", status_code=204)
def delete_item(item_id: int):
    with get_session() as session:
        item = session.get(Item, item_id)
        if not item:
            raise HTTPException(status_code=404, detail="Item not found")
        session.delete(item)
        session.commit()
        return


# ---- Optional: quick stock adjust (increase/decrease) ----
@router.post("/{item_id}/adjust", response_model=ItemOut)
def adjust_stock(
    item_id: int,
    delta: int = Query(..., description="Positive or negative integer"),
    note: Optional[str] = Query(None, description="Optional note for ledger (e.g., purchase, damage, correction)"),
):
    with get_session() as session:
        try:
            item = session.get(Item, item_id)
            if not item:
                raise HTTPException(status_code=404, detail="Item not found")

            new_stock = item.stock + int(delta)
            if new_stock < 0:
                raise HTTPException(status_code=400, detail="Stock would go negative")

            item.stock = new_stock
            item.updated_at = now_ts()
            session.add(item)

            # ✅ Ledger row for manual adjustment
            if int(delta) != 0:
                add_movement(
                    session,
                    item_id=item.id,
                    delta=int(delta),
                    reason="ADJUST",
                    ref_type="MANUAL",
                    ref_id=None,
                    note=(note.strip() if note else None),
                )

            session.commit()
            session.refresh(item)
            return item

        except HTTPException:
            raise
        except Exception as e:
            session.rollback()
            raise HTTPException(status_code=500, detail=f"Adjust stock failed: {e}")


# ---------------- Ledger API (NEW) ----------------
@router.get("/{item_id}/ledger", response_model=StockLedgerPageOut)
def item_ledger(
    item_id: int,
    limit: int = Query(50, ge=1, le=500),
    offset: int = Query(0, ge=0),
    from_date: Optional[str] = Query(None, description="YYYY-MM-DD"),
    to_date: Optional[str] = Query(None, description="YYYY-MM-DD (inclusive)"),
    reason: Optional[str] = Query(None, description="Filter by reason"),
):
    """
    Returns newest-first ledger rows for a single item.
    Also includes balance_before / balance_after for each row.

    Balance computation strategy (fast):
    - Start from current Item.stock
    - Walk backwards over movements (newest -> older)
    - For each movement:
        after = running
        before = after - delta
        running = before
    """
    with get_session() as session:
        item = session.get(Item, item_id)
        if not item:
            raise HTTPException(status_code=404, detail="Item not found")

        stmt = select(StockMovement).where(StockMovement.item_id == item_id)

        if from_date:
            stmt = stmt.where(StockMovement.ts >= f"{from_date}T00:00:00")
        if to_date:
            stmt = stmt.where(StockMovement.ts <= f"{to_date}T23:59:59")

        if reason:
            stmt = stmt.where(func.lower(StockMovement.reason) == reason.strip().lower())

        stmt = stmt.order_by(StockMovement.id.desc()).limit(limit + 1).offset(offset)
        rows = session.exec(stmt).all()

        has_more = len(rows) > limit
        if has_more:
            rows = rows[:limit]

        running = int(item.stock or 0)
        out: List[StockMovementOut] = []

        for m in rows:
            after = running
            before = after - int(m.delta or 0)

            out.append(StockMovementOut(
                id=m.id,
                ts=m.ts,
                delta=int(m.delta or 0),
                reason=m.reason,
                ref_type=getattr(m, "ref_type", None),
                ref_id=getattr(m, "ref_id", None),
                note=getattr(m, "note", None),
                actor=getattr(m, "actor", None),
                balance_after=after,
                balance_before=before,
            ))

            running = before

        next_offset = (offset + limit) if has_more else None

        return {
            "item_id": item.id,
            "item_name": item.name,
            "current_stock": int(item.stock or 0),
            "items": out,
            "next_offset": next_offset,
        }
